var documenterSearchIndex = {"docs":
[{"location":"manual/State/#State-representation-in-HadaMAG.jl","page":"State","title":"State representation in HadaMAG.jl","text":"","category":"section"},{"location":"manual/State/#HadaMAG.StateVec","page":"State","title":"HadaMAG.StateVec","text":"StateVec\n\nA lightweight container for a pure quantum state of n q-dits (q = qudit dimension, 2 for qubits) stored in the computational basis |0⋯00⟩, |0⋯01⟩, …, |q−1⋯(q−1)⟩.\n\n\n\n\n\n","category":"type"},{"location":"manual/State/#HadaMAG.StateVec-Union{Tuple{AbstractVector{<:Complex{T}}}, Tuple{T}} where T","page":"State","title":"HadaMAG.StateVec","text":"StateVec(vec::AbstractVector{<:Complex}; q::Int = 2)\n\nCreate a StateVec from an existing amplitude vector vec. Throws ArgumentError if length(vec) is not an exact power of q.\n\nArguments\n\nvec: Vector of complex amplitudes.\nq: Dimension of each qudit (default = 2 for qubits).\n\nReturns\n\nA StateVec containing a copy of vec and inferred n & q.\n\nExample\n\njulia> ψ = randn(ComplexF64, 2^4);\njulia> StateVec(ψ) # defaults to qubits\nStateVec{Float64,2}(n=4, q=2)\n\n\n\n\n\n","category":"method"},{"location":"manual/State/#HadaMAG.apply_2gate!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 1}, AbstractArray{Complex{T}, 2}, Int64, Int64}} where T","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(state::AbstractVector{Complex{T}}, gate::AbstractMatrix{Complex{T}}, q1::Int, q2::Int)\n\nApply in-place a two-qubit gate (4×4 matrix) to qubits q1,q2 (1-based) on state. state must have length 2^n and contain amplitude data in computational basis.\n\n\n\n\n\n","category":"method"},{"location":"manual/State/#HadaMAG.apply_2gate!-Union{Tuple{T}, Tuple{StateVec{T, 2}, AbstractArray{Complex{T}, 2}, Int64, Int64}} where T","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(sv::StateVec{T,2}, gate::AbstractMatrix{Complex{T}}, q1::Int, q2::Int)\n\nApply a two-qubit gate directly on a StateVec{T,2}.\n\n\n\n\n\n","category":"method"},{"location":"manual/State/#HadaMAG.apply_brick_wall_haar!","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(state::AbstractVector{ComplexF64}, nqubits::Integer, depth::Integer; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply an in-place “brick-wall” of Haar-random 2-qubit unitaries to state. The circuit has depth layers; odd layers act on qubits (1,2),(3,4)…, even on (2,3),(4,5)…\n\nArguments\n\nstate: length-2^nqubits state vector (will be mutated).\nnqubits: number of qubits.\ndepth: number of alternating layers.\nrng: keyword RNG (defaults to GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"manual/State/#HadaMAG.apply_brick_wall_haar!-Union{Tuple{T}, Tuple{StateVec{T, 2}, Int64}, Tuple{StateVec{T, 2}, Int64, Random.AbstractRNG}} where T","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(ψ::StateVec{T,2}, L::Int, depth::Int, rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply a brick-wall Haar-random circuit to a state vector vec in-place. The circuit consists of depth layers of random unitary 2-qubit gates, alternating between even and odd qubit pairs.\n\nArguments\n\nψ: StateVec to be modified.\ndepth: Number of layers of gates.\nrng: Random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"},{"location":"manual/State/#HadaMAG.load_state-Tuple{AbstractString}","page":"State","title":"HadaMAG.load_state","text":"load_state(path::AbstractString; q::Int = 2) -> StateVec\n\nLoad a state vector from disk into a StateVec. The loaded vector is not renormalized; ensure it has unit norm if required.\n\nSupported formats (by file extension):\n\n.jld2: Reads dataset \"state\" via JLD2.jl.\n.npy:  Reads NumPy array via NPZ.jl.\nOtherwise: Whitespace-delimited real and imaginary parts.\n\nArguments\n\npath: Path to the file containing state amplitudes.\nq: Dimension of each qudit (default = 2).\n\nReturns\n\nA StateVec constructed from the loaded data.\n\n\n\n\n\n","category":"method"},{"location":"manual/State/#HadaMAG.rand_haar-Tuple{Int64}","page":"State","title":"HadaMAG.rand_haar","text":"rand_haar(n::Int, depth::Int; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-random state on n qubits of local dimension 2, normalized to unit norm.\n\nArguments\n\ndepth::Int: number of layers of random 2-qudit gates (brick-wall pattern) to apply to a state vector initialized with iid complex Gaussian entries.\n\nKeyword Arguments\n\nrng::AbstractRNG: random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"},{"location":"#HadaMAG.jl-Documentation","page":"Home","title":"HadaMAG.jl Documentation","text":"","category":"section"}]
}
