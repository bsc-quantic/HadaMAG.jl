var documenterSearchIndex = {"docs":
[{"location":"manual/CustomFHT/#Custom-FHT-Library","page":"Custom FHT Library","title":"Custom FHT Library","text":"","category":"section"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"Under the hood, HadaMAG’s Fast Hadamard Transform (FHT) is powered by the FastHadamardStructuredTransforms_jll package (a Julia Binary Library artifact built via the Yggdrasil infrastructure).  This gives you a portable, pre-built C library (the upstream FFHT project) out of the box, with zero fuss on installation.","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"However, it is important to note that these binaries prioritize compatibility over peak performance. Therefore, by compiling FFHT yourself with optimizations tuned to your CPU (for example passing -march=native, enabling link-time optimization, or targeting advanced SIMD extensions), you can often unlock around 10-30 % faster transforms on large vectors. Since HadaMAG’s core routines rely heavily on FHT, those gains translate directly into substantial runtime savings.","category":"page"},{"location":"manual/CustomFHT/#Usage-and-Performance-Comparison","page":"Custom FHT Library","title":"Usage and Performance Comparison","text":"","category":"section"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"Here we show how we can easily switch libraries, and compare the performance of the default JLL-provided library with a custom-compiled one.","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"julia> using HadaMAG, BenchmarkTools\n\njulia> L = 22; v = randn(2^L); # around 4 million elements\n\n# Default JLL library\njulia> @btime HadaMAG.call_fht!(v, Int32(L))\n  8.250 ms (0 allocations: 0 bytes)\n\n# Override with your custom build\njulia> HadaMAG.use_fht_lib(\"/home/user/libffht_julia.so\")\n[ Info: Using custom FHT library at /home/user/libffht_julia.so\n\njulia> @btime HadaMAG.call_fht!(v, Int32(L)) # Speedup compared to JLL\n  6.258 ms (0 allocations: 0 bytes)\n\n# We can also revert back to the default JLL library\njulia> HadaMAG.use_default_fht()\n[ Info: Reverting to default FHT library\n\njulia> @btime HadaMAG.call_fht!(v, Int32(L))\n  8.642 ms (0 allocations: 0 bytes)","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"In this example, we see that the custom-compiled library provides a significant speedup over the default JLL library. You can expect similar results on your own machine, depending on your CPU architecture and the optimizations you apply during compilation.","category":"page"},{"location":"manual/CustomFHT/#API-Reference","page":"Custom FHT Library","title":"API Reference","text":"","category":"section"},{"location":"manual/CustomFHT/#HadaMAG.call_fht!","page":"Custom FHT Library","title":"HadaMAG.call_fht!","text":"call_fht!(vec::Vector{Float64}, L::Int32)\n\nIn‐place fast Hadamard transform.  After an optional call to use_fht_lib, this will call through your .so instead of the default JLL library.\n\n\n\n\n\n","category":"function"},{"location":"manual/CustomFHT/#HadaMAG.use_fht_lib","page":"Custom FHT Library","title":"HadaMAG.use_fht_lib","text":"use_fht_lib(path::String)\n\nPoint at your own compiled .so that exports exactly the symbol :fht_double. After calling this, every call_fht! will invoke your library instead of the JLL one.\n\n\n\n\n\n","category":"function"},{"location":"manual/CustomFHT/#HadaMAG.use_default_fht","page":"Custom FHT Library","title":"HadaMAG.use_default_fht","text":"use_default_fht()\n\nRevert call_fht! back to the built-in FastHadamardStructuredTransforms_jll implementation.\n\n\n\n\n\n","category":"function"},{"location":"#HadaMAG.jl-Documentation","page":"Home","title":"HadaMAG.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Performance tip\nIf you’re processing large vectors or doing millions of transforms, you can get up to 30 % more speed by compiling and linking your own optimized FFHT library. See the Custom FHT Library guide for how to build, enable and revert your own .so.","category":"page"},{"location":"api/Helpers/#Helper-functions-in-HadaMAG.jl","page":"Helpers","title":"Helper functions in HadaMAG.jl","text":"","category":"section"},{"location":"api/Helpers/#HadaMAG.haar_random_unitary","page":"Helpers","title":"HadaMAG.haar_random_unitary","text":"haar_random_unitary(n_qubits::Integer, rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-distributed random unitary matrix of size 2^nqubits × 2^nqubits.\n\nArguments\n\nn_qubits::Integer: number of qubits; the output U lives in U(2^n_qubits).\nrng::AbstractRNG: random number generator (defaults to GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"api/State/#State-representation-in-HadaMAG.jl","page":"State","title":"State representation in HadaMAG.jl","text":"","category":"section"},{"location":"api/State/#HadaMAG.StateVec","page":"State","title":"HadaMAG.StateVec","text":"StateVec\n\nA lightweight container for a pure quantum state of n q-dits (q = qudit dimension, 2 for qubits) stored in the computational basis |0⋯00⟩, |0⋯01⟩, …, |q−1⋯(q−1)⟩.\n\n\n\n\n\n","category":"type"},{"location":"api/State/#HadaMAG.StateVec-Union{Tuple{AbstractVector{<:Complex{T}}}, Tuple{T}} where T","page":"State","title":"HadaMAG.StateVec","text":"StateVec(vec::AbstractVector{<:Complex}; q::Int = 2)\n\nCreate a StateVec from an existing amplitude vector vec. Throws ArgumentError if length(vec) is not an exact power of q.\n\nArguments\n\nvec: Vector of complex amplitudes.\nq: Dimension of each qudit (default = 2 for qubits).\n\nReturns\n\nA StateVec containing a copy of vec and inferred n & q.\n\nExample\n\njulia> ψ = randn(ComplexF64, 2^4);\njulia> StateVec(ψ) # defaults to qubits\nStateVec{Float64,2}(n=4, q=2)\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_2gate!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 1}, AbstractArray{Complex{T}, 2}, Int64, Int64}} where T","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(state::AbstractVector{Complex{T}}, gate::AbstractMatrix{Complex{T}}, q1::Int, q2::Int)\n\nApply in-place a two-qubit gate (4×4 matrix) to qubits q1,q2 (1-based) on state. state must have length 2^n and contain amplitude data in computational basis.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_2gate!-Union{Tuple{T}, Tuple{StateVec{T, 2}, AbstractArray{Complex{T}, 2}, Int64, Int64}} where T","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(sv::StateVec{T,2}, gate::AbstractMatrix{Complex{T}}, q1::Int, q2::Int)\n\nApply a two-qubit gate directly on a StateVec{T,2}.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_brick_wall_haar!","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(state::AbstractVector{ComplexF64}, nqubits::Integer, depth::Integer; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply an in-place “brick-wall” of Haar-random 2-qubit unitaries to state. The circuit has depth layers; odd layers act on qubits (1,2),(3,4)…, even on (2,3),(4,5)…\n\nArguments\n\nstate: length-2^nqubits state vector (will be mutated).\nnqubits: number of qubits.\ndepth: number of alternating layers.\nrng: keyword RNG (defaults to GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"api/State/#HadaMAG.apply_brick_wall_haar!-Union{Tuple{T}, Tuple{StateVec{T, 2}, Int64}, Tuple{StateVec{T, 2}, Int64, Random.AbstractRNG}} where T","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(ψ::StateVec{T,2}, L::Int, depth::Int, rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply a brick-wall Haar-random circuit to a state vector vec in-place. The circuit consists of depth layers of random unitary 2-qubit gates, alternating between even and odd qubit pairs.\n\nArguments\n\nψ: StateVec to be modified.\ndepth: Number of layers of gates.\nrng: Random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.load_state-Tuple{AbstractString}","page":"State","title":"HadaMAG.load_state","text":"load_state(path::AbstractString; q::Int = 2) -> StateVec\n\nLoad a state vector from disk into a StateVec. The loaded vector is not renormalized; ensure it has unit norm if required.\n\nSupported formats (by file extension):\n\n.jld2: Reads dataset \"state\" via JLD2.jl.\n.npy:  Reads NumPy array via NPZ.jl.\nOtherwise: Whitespace-delimited real and imaginary parts.\n\nArguments\n\npath: Path to the file containing state amplitudes.\nq: Dimension of each qudit (default = 2).\n\nReturns\n\nA StateVec constructed from the loaded data.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.rand_haar-Tuple{Int64}","page":"State","title":"HadaMAG.rand_haar","text":"rand_haar(n::Int, depth::Int; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-random state on n qubits of local dimension 2, normalized to unit norm.\n\nArguments\n\ndepth::Int: number of layers of random 2-qudit gates (brick-wall pattern) to apply to a state vector initialized with iid complex Gaussian entries.\n\nKeyword Arguments\n\nrng::AbstractRNG: random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"}]
}
