var documenterSearchIndex = {"docs":
[{"location":"manual/CustomFHT/#Custom-FHT-Library","page":"Custom FHT Library","title":"Custom FHT Library","text":"","category":"section"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"Under the hood, HadaMAG’s Fast Hadamard Transform (FHT) is powered by the FastHadamardStructuredTransforms_jll package—a JLL (Julia Binary Library) artifact built via the Yggdrasil infrastructure.  This gives you a portable, pre-built C library (the upstream FFHT project) out of the box, with zero fuss on installation.","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"However, it is important to note that those binaries are compiled for maximum compatibility rather than performance.","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"By compiling FFHT yourself (passing the proper -march to exploit your CPU’s full instruction set, enabling Link-Time Optimization (LTO) or Profile-Guided Optimization (PGO), targeting advanced SIMD extensions such as AVX2 or AVX-512, and stripping out debug symbols to permit more aggressive inlining) you can often unlock around 1030  faster transforms on large vectors. Since our main HadaMAG functions rely heavily on FHT operations, those optimizations translate into substantial runtime savings and a game-changing performance uplift.","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"In the following, we show you how to:","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"Build your own libffht_julia.so from the upstream FFHT sources\nHook it into HadaMAG with use_fht_lib(...)\nVerify the speedup\nRevert back to the default JLL-provided library if desired","category":"page"},{"location":"manual/CustomFHT/#Usage","page":"Custom FHT Library","title":"Usage","text":"","category":"section"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"Build your own libffht_julia.so, making sure it exports the symbol :fht_double.\nIn your Julia session or script:\n```@repl  using HadaMAG\nPoint at your custom library (only needs to be called once)\nHadaMAG.usefhtlib(\"/home/user/path/to/libffht_julia.so\")\nNow do your transforms\nv = randn(1000000)  HadaMAG.call_fht!(v, Int32(length(v)))  ```\nBenchmark to confirm:\n```@repl  using BenchmarkTools\nv = randn(1000000)\ndefault\n@btime HadaMAG.call_fht!(v Int32(length(v)))\ncustom\nHadaMAG.usefhtlib(\"/home/user/libffhtjulia.so\")  @btime HadaMAG.callfht!(v Int32(length(v)))  ```","category":"page"},{"location":"manual/CustomFHT/#Reverting-to-the-default","page":"Custom FHT Library","title":"Reverting to the default","text":"","category":"section"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"If you want to revert back to the default JLL-provided library, simply call:","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"HadaMAG.use_default_fht()","category":"page"},{"location":"#HadaMAG.jl-Documentation","page":"Home","title":"HadaMAG.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Performance tip\nIf you’re processing large vectors or doing millions of transforms, you can get up to 30 % more speed by compiling and linking your own optimized FFHT library. See the Custom FHT Library guide for how to build, enable and revert your own .so.","category":"page"},{"location":"api/Helpers/#Helper-functions-in-HadaMAG.jl","page":"Helpers","title":"Helper functions in HadaMAG.jl","text":"","category":"section"},{"location":"api/Helpers/#HadaMAG.haar_random_unitary","page":"Helpers","title":"HadaMAG.haar_random_unitary","text":"haar_random_unitary(n_qubits::Integer, rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-distributed random unitary matrix of size 2^nqubits × 2^nqubits.\n\nArguments\n\nn_qubits::Integer: number of qubits; the output U lives in U(2^n_qubits).\nrng::AbstractRNG: random number generator (defaults to GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"api/State/#State-representation-in-HadaMAG.jl","page":"State","title":"State representation in HadaMAG.jl","text":"","category":"section"},{"location":"api/State/#HadaMAG.StateVec","page":"State","title":"HadaMAG.StateVec","text":"StateVec\n\nA lightweight container for a pure quantum state of n q-dits (q = qudit dimension, 2 for qubits) stored in the computational basis |0⋯00⟩, |0⋯01⟩, …, |q−1⋯(q−1)⟩.\n\n\n\n\n\n","category":"type"},{"location":"api/State/#HadaMAG.StateVec-Union{Tuple{AbstractVector{<:Complex{T}}}, Tuple{T}} where T","page":"State","title":"HadaMAG.StateVec","text":"StateVec(vec::AbstractVector{<:Complex}; q::Int = 2)\n\nCreate a StateVec from an existing amplitude vector vec. Throws ArgumentError if length(vec) is not an exact power of q.\n\nArguments\n\nvec: Vector of complex amplitudes.\nq: Dimension of each qudit (default = 2 for qubits).\n\nReturns\n\nA StateVec containing a copy of vec and inferred n & q.\n\nExample\n\njulia> ψ = randn(ComplexF64, 2^4);\njulia> StateVec(ψ) # defaults to qubits\nStateVec{Float64,2}(n=4, q=2)\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_2gate!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 1}, AbstractArray{Complex{T}, 2}, Int64, Int64}} where T","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(state::AbstractVector{Complex{T}}, gate::AbstractMatrix{Complex{T}}, q1::Int, q2::Int)\n\nApply in-place a two-qubit gate (4×4 matrix) to qubits q1,q2 (1-based) on state. state must have length 2^n and contain amplitude data in computational basis.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_2gate!-Union{Tuple{T}, Tuple{StateVec{T, 2}, AbstractArray{Complex{T}, 2}, Int64, Int64}} where T","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(sv::StateVec{T,2}, gate::AbstractMatrix{Complex{T}}, q1::Int, q2::Int)\n\nApply a two-qubit gate directly on a StateVec{T,2}.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_brick_wall_haar!","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(state::AbstractVector{ComplexF64}, nqubits::Integer, depth::Integer; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply an in-place “brick-wall” of Haar-random 2-qubit unitaries to state. The circuit has depth layers; odd layers act on qubits (1,2),(3,4)…, even on (2,3),(4,5)…\n\nArguments\n\nstate: length-2^nqubits state vector (will be mutated).\nnqubits: number of qubits.\ndepth: number of alternating layers.\nrng: keyword RNG (defaults to GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"api/State/#HadaMAG.apply_brick_wall_haar!-Union{Tuple{T}, Tuple{StateVec{T, 2}, Int64}, Tuple{StateVec{T, 2}, Int64, Random.AbstractRNG}} where T","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(ψ::StateVec{T,2}, L::Int, depth::Int, rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply a brick-wall Haar-random circuit to a state vector vec in-place. The circuit consists of depth layers of random unitary 2-qubit gates, alternating between even and odd qubit pairs.\n\nArguments\n\nψ: StateVec to be modified.\ndepth: Number of layers of gates.\nrng: Random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.load_state-Tuple{AbstractString}","page":"State","title":"HadaMAG.load_state","text":"load_state(path::AbstractString; q::Int = 2) -> StateVec\n\nLoad a state vector from disk into a StateVec. The loaded vector is not renormalized; ensure it has unit norm if required.\n\nSupported formats (by file extension):\n\n.jld2: Reads dataset \"state\" via JLD2.jl.\n.npy:  Reads NumPy array via NPZ.jl.\nOtherwise: Whitespace-delimited real and imaginary parts.\n\nArguments\n\npath: Path to the file containing state amplitudes.\nq: Dimension of each qudit (default = 2).\n\nReturns\n\nA StateVec constructed from the loaded data.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.rand_haar-Tuple{Int64}","page":"State","title":"HadaMAG.rand_haar","text":"rand_haar(n::Int, depth::Int; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-random state on n qubits of local dimension 2, normalized to unit norm.\n\nArguments\n\ndepth::Int: number of layers of random 2-qudit gates (brick-wall pattern) to apply to a state vector initialized with iid complex Gaussian entries.\n\nKeyword Arguments\n\nrng::AbstractRNG: random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"}]
}
