var documenterSearchIndex = {"docs":
[{"location":"manual/ExactSRE/#Exact-Stabilizer-Rényi-Entropy-(SRE)","page":"Exact SRE","title":"Exact Stabilizer Rényi Entropy (SRE)","text":"","category":"section"},{"location":"manual/ExactSRE/","page":"Exact SRE","title":"Exact SRE","text":"The Stabilizer Rényi Entropy (SRE) of order q is a measure of the non-stabilizer content of a pure quantum state  ψ . Under the hood, HadaMAG.SRE(ψ, q) dispatches to one of several backends (:serial, :threads, or :mpi) and uses a sequence of Fast Hadamard Transforms to reduce the naive O(4^n) sum down to O(n2^n) work.","category":"page"},{"location":"manual/ExactSRE/","page":"Exact SRE","title":"Exact SRE","text":"By default, backend = :auto chooses the fastest available execution engine. For details on available backends and MPI usage, see the Backend Configuration guide.","category":"page"},{"location":"manual/ExactSRE/#Usage","page":"Exact SRE","title":"Usage","text":"","category":"section"},{"location":"manual/ExactSRE/","page":"Exact SRE","title":"Exact SRE","text":"julia> using HadaMAG\n\n# Prepare a Haar random state of size L with a specified depth\njulia> L = 8; ψ = rand_haar(L; depth=2)\n\n# Compute the 2nd-order SRE with automatic backend selection (in this case, muli-threaded)\njulia> SRE(ψ, 2)\n[==================================================] 100.0%  (256/256)\n(6.009572767520443, 4.440892098500626e-16)\n\n# Force the serial backend (not multi-threaded)\njulia> SRE(ψ, 2; backend = :serial)\n[==================================================] 100.0%  (256/256)\n(6.0095727675204405, 6.661338147750939e-16)","category":"page"},{"location":"manual/ExactSRE/","page":"Exact SRE","title":"Exact SRE","text":"In each call you get a tuple (entropy, lost_norm), where lost_norm is the numerical deviation from unit norm after applying the algorithm.","category":"page"},{"location":"manual/ExactSRE/#API-Reference","page":"Exact SRE","title":"API Reference","text":"","category":"section"},{"location":"manual/ExactSRE/#HadaMAG.SRE","page":"Exact SRE","title":"HadaMAG.SRE","text":"SRE(ψ::StateVec{T,2}; backend = :auto)\n\nCompute the exact Stabilizer Renyi entropy (q) of a quantum state ψ using the HadaMAG algorithm. Returns the SRE value and the lost norm of the state vector.\n\nArguments\n\nψ: A StateVec object representing the quantum state.\nq: The Renyi index (the most common value is 2).\n\nKeyword Arguments\n\nbackend: The backend to use for the computation. Default is :auto, which selects the best available backend.\nprogress: Whether to show a progress bar. Default to true.\n\n\n\n\n\n","category":"function"},{"location":"manual/MCSRE/#Monte-Carlo-Stabilizer-Rényi-Entropy-(MC-SRE)","page":"Monte Carlo SRE","title":"Monte Carlo Stabilizer Rényi Entropy (MC-SRE)","text":"","category":"section"},{"location":"manual/MCSRE/","page":"Monte Carlo SRE","title":"Monte Carlo SRE","text":"The HadaMAG.jl library provides a Monte Carlo method for estimating the Stabilizer Rényi Entropy of order q for a pure quantum state ψ.","category":"page"},{"location":"manual/MCSRE/","page":"Monte Carlo SRE","title":"Monte Carlo SRE","text":"The HadaMAG.MC_SRE(ψ, q; Nsamples=1000, Nβ=13, backend=:auto) function estimates the SRE using a Monte Carlo sampling approach, where Nsamples is the number of samples to draw and Nβ is the number of discrete distribution points used in the estimation.","category":"page"},{"location":"manual/MCSRE/","page":"Monte Carlo SRE","title":"Monte Carlo SRE","text":"Under the hood, HadaMAG.MC_SRE(ψ, q) dispatches to one of several backends (:serial, :threads, or :mpi). By default, backend = :auto chooses the fastest available execution engine. For details on available backends and MPI usage, see the Backend Configuration guide.","category":"page"},{"location":"manual/MCSRE/#Usage","page":"Monte Carlo SRE","title":"Usage","text":"","category":"section"},{"location":"manual/MCSRE/","page":"Monte Carlo SRE","title":"Monte Carlo SRE","text":"julia> using HadaMAG\n\n# Prepare a Haar random state of size L with a specified depth\njulia> L = 8; ψ = rand_haar(L; depth=2)\n\n# Compute the exact 2nd-order SRE for reference\njulia> SRE(ψ, 2)\n[==================================================] 100.0%  (256/256)\n(6.005977237090554, 6.661338147750939e-16)\n\n# Estimate the 2nd-order SRE using Monte Carlo with 1000 samples\njulia> MC_SRE(ψ, 2; Nsamples=1000)\n[==================================================] 100.0%  (1000/1000)\n5.9989388155066194\n\n# Estimate the 2nd-order SRE using Monte Carlo with 10000 samples\njulia> MC_SRE(ψ, 2; Nsamples=10000)\n[==================================================] 100.0%  (10000/10000)\n6.00198832046363","category":"page"},{"location":"manual/Mana/#Mana-Computation","page":"Mana Computation","title":"Mana Computation","text":"","category":"section"},{"location":"manual/Mana/","page":"Mana Computation","title":"Mana Computation","text":"The HadaMAG.jl library also provides functionality to compute the mana of a quantum state for qutrits. Similar to HadaMAG.SRE, the HadaMAG.Mana(ψ) function computes the exact mana using Fast Hadamard Transforms (FHT) to reduce the naive ? complexity down to ?.","category":"page"},{"location":"manual/Mana/","page":"Mana Computation","title":"Mana Computation","text":"Under the hood, HadaMAG.Mana(ψ, q) dispatches to one of several backends (:serial, :threads, or :mpi).","category":"page"},{"location":"manual/Mana/","page":"Mana Computation","title":"Mana Computation","text":"By default, backend = :auto chooses the fastest available execution engine. For details on available backends and MPI usage, see the Backend Configuration guide.","category":"page"},{"location":"manual/Mana/#Usage","page":"Mana Computation","title":"Usage","text":"","category":"section"},{"location":"manual/Mana/","page":"Mana Computation","title":"Mana Computation","text":"julia> using HadaMAG\n\n# Prepare a random state of size L=6\njulia> L = 6; amplitudes = rand(ComplexF64, 3^L);\n\njulia> ψ = StateVec(amplitudes; q=3); normalize!(ψ); ψ\nStateVec{ComplexF64,3}(n=6, dim=729, mem=11.4 KiB)\n\n# Compute the mana with automatic backend selection (in this case, muli-threaded)\njulia> Mana(ψ)\n[==================================================] 100.0%  (729/729)\n8.556666992528807\n\n# Force the serial backend (not multi-threaded)\njulia> Mana(ψ; backend = :serial)\n[==================================================] 100.0%  (729/729)\n8.556666992528806","category":"page"},{"location":"manual/State/#State-representation-in-HadaMAG.jl","page":"State Representation","title":"State representation in HadaMAG.jl","text":"","category":"section"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"In HadaMAG.jl, the StateVec{T,q} type provides a simple, efficient representation of an n-qudit (local dimension q) quantum state in the computational basis, with support for constructing from raw amplitude vectors, generating Haar-random states, loading from common on-disk formats and other utilities.","category":"page"},{"location":"manual/State/#Constructing-a-StateVec{T,q}","page":"State Representation","title":"Constructing a StateVec{T,q}","text":"","category":"section"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"Create from an existing amplitude vector (must have length = q^n):","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"julia> using HadaMAG\n\njulia> amplitudes = randn(ComplexF64, 2^4);\n\njulia> ψ = StateVec(amplitudes) # defaults to q=2 (qubits)\nStateVec{ComplexF64,2}(n=4, dim=16, mem=296.0 B)","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"Or specify a non-qubit local dimension:","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"julia> amplitudes = randn(ComplexF64, 3^3);\n\njulia> ψ = StateVec(amplitudes; q=3) # qutrits\nStateVec{ComplexF64,3}(n=3, dim=27, mem=472.0 B)","category":"page"},{"location":"manual/State/#Sampling-Haar-random-states","page":"State Representation","title":"Sampling Haar-random states","text":"","category":"section"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"Generate a Haar-random state on n qubits, using depth layers of random 2-qubit gates:","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"julia> ψ = rand_haar(4; depth=3)\nStateVec{Float64,2}(n=4, dim=16, mem=...)","category":"page"},{"location":"manual/State/#Loading-a-state-vector-from-disk","page":"State Representation","title":"Loading a state vector from disk","text":"","category":"section"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"You can load amplitude data from various on-disk formats into a StateVec. The data is not renormalized automatically, so make sure your file encodes a unit-norm state.","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"Supported formats (by extension):","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":".jld2: JLD2 format (with JLD2.jl)\n.npy: NumPy format (with NPZ.jl)\n.txt and other text formats: Whitespace-delimited real and imaginary parts.","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"julia> using LinearAlgebra\n\njulia> ψ = load_state(\"state_L_12.txt\")\nStateVec{ComplexF64,2}(n=12, dim=4096, mem=64.0 KiB)\n\njulia> norm(ψ)\n1.0","category":"page"},{"location":"manual/State/#API-Reference","page":"State Representation","title":"API Reference","text":"","category":"section"},{"location":"manual/State/#HadaMAG.rand_haar","page":"State Representation","title":"HadaMAG.rand_haar","text":"rand_haar(n::Int, depth::Int; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-random state on n qubits of local dimension 2, normalized to unit norm.\n\nArguments\n\ndepth::Int: number of layers of random 2-qudit gates (brick-wall pattern) to apply to a state vector initialized with iid complex Gaussian entries.\n\nKeyword Arguments\n\nrng::AbstractRNG: random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"manual/State/#HadaMAG.load_state","page":"State Representation","title":"HadaMAG.load_state","text":"load_state(path::AbstractString; q::Int = 2) -> StateVec\n\nLoad a state vector from disk into a StateVec. The loaded vector is not renormalized; ensure it has unit norm if required.\n\nSupported formats (by file extension):\n\n.jld2: Reads dataset \"state\" via JLD2.jl.\n.npy:  Reads NumPy array via NPZ.jl.\nOtherwise: Whitespace-delimited real and imaginary parts.\n\nArguments\n\npath: Path to the file containing state amplitudes.\nq: Dimension of each qudit (default = 2).\n\nReturns\n\nA StateVec constructed from the loaded data.\n\n\n\n\n\n","category":"function"},{"location":"manual/Backends/#Backend-Configuration","page":"Backend Configuration","title":"Backend Configuration","text":"","category":"section"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"HadaMAG can run its kernels on different execution engines depending on your hardware and environment. We call these backends.","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"There are three available backends:","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"Serial – single-threaded CPU execution.\nThreaded – multi-threaded CPU execution (uses Julia Threads).\nMPIThreads – hybrid MPI + threads execution (one or more threads per MPI rank).","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"You choose the backend with the backend keyword in user-facing functions, e.g.:","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"julia> SRE(ψ, q; backend = :auto)   # default is :auto","category":"page"},{"location":"manual/Backends/#Backend-types-and-symbols","page":"Backend Configuration","title":"Backend types and symbols","text":"","category":"section"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"Internally we define three backend types:","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"abstract type AbstractBackend end\nstruct Serial      <: AbstractBackend end\nstruct Threaded    <: AbstractBackend end\nstruct MPIThreads  <: AbstractBackend end  # defined even if MPI is absent","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"These map to the following keyword symbols:","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"backend = :serial to Serial().\nbackend = :threads to Threaded().\nbackend = :mpi to MPIThreads().\nbackend = :auto (default) to automatic selection.","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"You can force an specific backend by passing the corresponding symbol to user functions:","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"julia> using HadaMAG\n\njulia> ψ = rand_haar(8; depth=2)\n\njulia> SRE(ψ, 2; backend = :threads)\n(6.0095727675204405, 6.661338147750939e-16)","category":"page"},{"location":"manual/Backends/#MPI-support-via-HadaMAGMPIExt-extension","page":"Backend Configuration","title":"MPI support via HadaMAGMPIExt extension","text":"","category":"section"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"Julia’s package extensions let us ship MPI code without hard-requiring MPI for everyone. Instead, The extension HadaMAGMPIExt is automatically discovered by Julia and activated when MPI.jl is loaded in your session.","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"As a user, you need to load MPI.jl before using HadaMAG with MPI:","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"julia> using HadaMAG\n\njulia> using Pkg; Pkg.add(\"MPI\"); using MPI\nPrecompiling HadaMAGMPIExt...\n  1 dependency successfully precompiled in 2 seconds. 341 already precompiled.","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"The MPI.jl package uses MPIPreferences.jl to decide which MPI implementation to load (a system MPI or a JLL/bundled MPI).","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"Use system MPI (e.g., OpenMPI or MPICH on a cluster):","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"julia> using MPIPreferences\n\njulia> MPIPreferences.MPIPreferences.use_system_binary()","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"Or use a bundled MPI (e.g., OpenMPI_jll):","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"julia> using MPIPreferences\n\njulia> MPIPreferences.MPIPreferences.use_jll_binary()","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"You can check which MPI you’re using with:","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"julia> using MPI\n\njulia> MPI.identify_implementation()\n(\"MPICH\", v\"4.3.1\")","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"This will use the system MPI installation.","category":"page"},{"location":"manual/Backends/#Running-using-MPI","page":"Backend Configuration","title":"Running using MPI","text":"","category":"section"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"Here we show a minimal example of running HadaMAG with MPI on a cluster or laptop. Create a file run_mpi.jl with the following content:","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"using MPI\n\nusing HadaMAG\nL = 8\nψ = HadaMAG.rand_haar(L; depth=2)\n\nS, lost = HadaMAG.SRE(ψ, 2; backend = :mpi_threads)\n\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\nprintln(\"rank=$rank  SRE=$S  lost_norm=$lost\")","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"Then run it with mpiexec or mpirun:","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"mpirun -n 4 julia --project yourproject run_sre.jl","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"Or if you are on a cluster with SLURM, you can submit a job script like this:","category":"page"},{"location":"manual/Backends/","page":"Backend Configuration","title":"Backend Configuration","text":"srun --ntasks=4 --cpus-per-task=1 julia --project yourproject run_sre.jl","category":"page"},{"location":"manual/Backends/#API-Reference","page":"Backend Configuration","title":"API Reference","text":"","category":"section"},{"location":"manual/CustomFHT/#Custom-FHT-Library","page":"Custom FHT Library","title":"Custom FHT Library","text":"","category":"section"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"Under the hood, HadaMAG’s Fast Hadamard Transform (FHT) is powered by the FastHadamardStructuredTransforms_jll package (a Julia Binary Library artifact built via the Yggdrasil infrastructure).  This gives you a portable, pre-built C library (the upstream FFHT project) out of the box, with zero fuss on installation.","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"However, it is important to note that these binaries prioritize compatibility over peak performance. Therefore, by compiling FFHT yourself with optimizations tuned to your CPU (for example passing -march=native, enabling link-time optimization, or targeting advanced SIMD extensions), you can often unlock around 10-30 % faster transforms on large vectors. Since HadaMAG’s core routines rely heavily on FHT, those gains translate directly into substantial runtime savings.","category":"page"},{"location":"manual/CustomFHT/#Usage-and-Performance-Comparison","page":"Custom FHT Library","title":"Usage and Performance Comparison","text":"","category":"section"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"Here we show how we can easily switch libraries, and compare the performance of the default JLL-provided library with a custom-compiled one.","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"julia> using HadaMAG, BenchmarkTools\n\njulia> L = 22; v = randn(2^L); # around 4 million elements\n\n# Default JLL library\njulia> @btime HadaMAG.call_fht!(v, Int32(L))\n  8.250 ms (0 allocations: 0 bytes)\n\n# Override with your custom build\njulia> HadaMAG.use_fht_lib(\"/home/user/libffht_julia.so\")\n[ Info: Using custom FHT library at /home/user/libffht_julia.so\n\njulia> @btime HadaMAG.call_fht!(v, Int32(L)) # Speedup compared to JLL\n  6.258 ms (0 allocations: 0 bytes)\n\n# We can also revert back to the default JLL library\njulia> HadaMAG.use_default_fht()\n[ Info: Reverting to default FHT library\n\njulia> @btime HadaMAG.call_fht!(v, Int32(L))\n  8.642 ms (0 allocations: 0 bytes)","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"In this example, we see that the custom-compiled library provides a significant speedup over the default JLL library. You can expect similar results on your own machine, depending on your CPU architecture and the optimizations you apply during compilation.","category":"page"},{"location":"manual/CustomFHT/#API-Reference","page":"Custom FHT Library","title":"API Reference","text":"","category":"section"},{"location":"manual/CustomFHT/#HadaMAG.call_fht!","page":"Custom FHT Library","title":"HadaMAG.call_fht!","text":"call_fht!(vec::Vector{Float64}, L::Int32)\n\nIn‐place fast Hadamard transform.  After an optional call to use_fht_lib, this will call through your .so instead of the default JLL library.\n\n\n\n\n\n","category":"function"},{"location":"manual/CustomFHT/#HadaMAG.use_fht_lib","page":"Custom FHT Library","title":"HadaMAG.use_fht_lib","text":"use_fht_lib(path::String)\n\nPoint at your own compiled .so that exports exactly the symbol :fht_double. After calling this, every call_fht! will invoke your library instead of the JLL one.\n\n\n\n\n\n","category":"function"},{"location":"manual/CustomFHT/#HadaMAG.use_default_fht","page":"Custom FHT Library","title":"HadaMAG.use_default_fht","text":"use_default_fht()\n\nRevert call_fht! back to the built-in FastHadamardStructuredTransforms_jll implementation.\n\n\n\n\n\n","category":"function"},{"location":"#HadaMAG.jl-Documentation","page":"Home","title":"HadaMAG.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HadaMAG.jl is an optimized Julia library for computing the Stabilizer Rényi Entropy (SRE) on pure quantum states. Most notably, it contains:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Exact SRE: Computes the exact SRE using the HadaMAG algorithm, which leverages Fast Hadamard Transforms (FHT) to reduce the naive O(4^n) complexity down to O(n2^n) (see Exact SRE).\nMonte Carlo SRE: Provides a Monte Carlo method for estimating SRE (see Monte Carlo SRE).\nMana Computation: Computes the exact mana of a quantum state for qutrits (see Mana Computation).","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Performance tip\nIf you are dealing with significant number of qubits (N  16), you can get around 30 % speed-up by compiling and linking your own optimized FFHT library. See the Custom FHT Library guide for how to build, enable and revert your own .so.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"HadaMAG\")\n\njulia> using HadaMAG\n\n# Prepare a Haar-random 8-qubit state\njulia> ψ = rand_haar(8; depth=2)\nStateVec{ComplexF64,2}(n=8, dim=256, mem=4.04 KiB)\n\n# Compute the 2nd‐order Stabilizer Rényi Entropy\njulia> (sre2, lost_norm) = SRE(ψ, 2)\n[==================================================] 100.0%  (256/256)\n(6.028326027457565, 1.1102230246251565e-16)\n\n# Estimate the 2nd‐order SRE using Monte Carlo with 10000 samples\njulia> sre2_mc = MC_SRE(ψ, 2; Nsamples=10000)\n[==================================================] 100.0%  (10000/10000)\n6.023172434713934","category":"page"},{"location":"#Manuals","page":"Home","title":"Manuals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For detailed guides on how to use HadaMAG.jl, see the following sections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"State Representation: How quantum states are represented in HadaMAG.jl.\nExact SRE: How to compute the exact Stabilizer Rényi Entropy.\nBackend Configuration: How to configure and use different backends for all SRE computation.","category":"page"},{"location":"api/Helpers/#Helper-functions-in-HadaMAG.jl","page":"Helpers","title":"Helper functions in HadaMAG.jl","text":"","category":"section"},{"location":"api/Helpers/#HadaMAG.build_tmp!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{ComplexF64}}","page":"Helpers","title":"HadaMAG.build_tmp!","text":"build_tmp!(tmp1, tmp2, X)\n\nCompute tmp1 = real(X)+imag(X), tmp2 = imag(X)-real(X) in place. X is the complex state vector (length = 2^L).\n\n\n\n\n\n","category":"method"},{"location":"api/Helpers/#HadaMAG.call_fht!-Tuple{Vector{Float64}, Int32}","page":"Helpers","title":"HadaMAG.call_fht!","text":"call_fht!(vec::Vector{Float64}, L::Int32)\n\nIn‐place fast Hadamard transform.  After an optional call to use_fht_lib, this will call through your .so instead of the default JLL library.\n\n\n\n\n\n","category":"method"},{"location":"api/Helpers/#HadaMAG.haar_random_unitary","page":"Helpers","title":"HadaMAG.haar_random_unitary","text":"haar_random_unitary(n_qubits::Integer, rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-distributed random unitary matrix of size 2^nqubits × 2^nqubits.\n\nArguments\n\nn_qubits::Integer: number of qubits; the output U lives in U(2^n_qubits).\nrng::AbstractRNG: random number generator (defaults to GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"api/Helpers/#HadaMAG.integrate_simpson_uniform-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Helpers","title":"HadaMAG.integrate_simpson_uniform","text":"integrate_simpson_uniform(x, y) -> Float64\n\nSimpson's rule on a uniform grid x. Requires an odd number of points.\n\n\n\n\n\n","category":"method"},{"location":"api/Helpers/#HadaMAG.use_default_fht-Tuple{}","page":"Helpers","title":"HadaMAG.use_default_fht","text":"use_default_fht()\n\nRevert call_fht! back to the built-in FastHadamardStructuredTransforms_jll implementation.\n\n\n\n\n\n","category":"method"},{"location":"api/Helpers/#HadaMAG.use_fht_lib-Tuple{String}","page":"Helpers","title":"HadaMAG.use_fht_lib","text":"use_fht_lib(path::String)\n\nPoint at your own compiled .so that exports exactly the symbol :fht_double. After calling this, every call_fht! will invoke your library instead of the JLL one.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#State-API-Documentation","page":"State","title":"State API Documentation","text":"","category":"section"},{"location":"api/State/#HadaMAG.StateVec","page":"State","title":"HadaMAG.StateVec","text":"HadaMAG.jl: StateVec\n\nA lightweight container for a pure quantum state of n q-dits (q = qudit dimension, 2 for qubits) stored in the computational basis |0⋯00⟩, |0⋯01⟩, …, |q−1⋯(q−1)⟩.\n\n\n\n\n\n","category":"type"},{"location":"api/State/#HadaMAG.StateVec-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"State","title":"HadaMAG.StateVec","text":"StateVec(vec::AbstractVector{<:Complex}; q::Int = 2)\n\nCreate a StateVec from an existing amplitude vector vec. Throws ArgumentError if length(vec) is not an exact power of q.\n\nArguments\n\nvec: Vector of complex amplitudes.\nq: Dimension of each qudit (default = 2 for qubits).\n\nReturns\n\nA StateVec containing a copy of vec and inferred n & q.\n\nExample\n\njulia> ψ = randn(ComplexF64, 2^4);\njulia> StateVec(ψ) # defaults to qubits\nStateVec{Float64,2}(n=4, q=2)\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_2gate!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 1}, AbstractArray{Complex{T}, 2}, Int64, Int64}} where T","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(state::AbstractVector{Complex{T}}, gate::AbstractMatrix{Complex{T}}, q1::Int, q2::Int)\n\nApply in-place a two-qubit gate (4×4 matrix) to qubits q1,q2 (1-based) on state. state must have length 2^n and contain amplitude data in computational basis.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_2gate!-Union{Tuple{T}, Tuple{StateVec{T, 2}, AbstractMatrix{T}, Int64, Int64}} where T","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(sv::StateVec{T,2}, gate::AbstractMatrix{T}, q1::Int, q2::Int)\n\nApply a two-qubit gate directly on a StateVec{T,2}.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_brick_wall_haar!","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(state::AbstractVector{ComplexF64}, nqubits::Integer, depth::Integer; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply an in-place “brick-wall” of Haar-random 2-qubit unitaries to state. The circuit has depth layers; odd layers act on qubits (1,2),(3,4)…, even on (2,3),(4,5)…\n\nArguments\n\nstate: length-2^nqubits state vector (will be mutated).\nnqubits: number of qubits.\ndepth: number of alternating layers.\nrng: keyword RNG (defaults to GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"api/State/#HadaMAG.apply_brick_wall_haar!-Union{Tuple{T}, Tuple{StateVec{T, 2}, Int64}, Tuple{StateVec{T, 2}, Int64, Random.AbstractRNG}} where T","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(ψ::StateVec{T,2}, L::Int, depth::Int, rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply a brick-wall Haar-random circuit to a state vector vec in-place. The circuit consists of depth layers of random unitary 2-qubit gates, alternating between even and odd qubit pairs.\n\nArguments\n\nψ: StateVec to be modified.\ndepth: Number of layers of gates.\nrng: Random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.load_state-Tuple{AbstractString}","page":"State","title":"HadaMAG.load_state","text":"load_state(path::AbstractString; q::Int = 2) -> StateVec\n\nLoad a state vector from disk into a StateVec. The loaded vector is not renormalized; ensure it has unit norm if required.\n\nSupported formats (by file extension):\n\n.jld2: Reads dataset \"state\" via JLD2.jl.\n.npy:  Reads NumPy array via NPZ.jl.\nOtherwise: Whitespace-delimited real and imaginary parts.\n\nArguments\n\npath: Path to the file containing state amplitudes.\nq: Dimension of each qudit (default = 2).\n\nReturns\n\nA StateVec constructed from the loaded data.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.rand_haar-Tuple{Int64}","page":"State","title":"HadaMAG.rand_haar","text":"rand_haar(n::Int, depth::Int; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-random state on n qubits of local dimension 2, normalized to unit norm.\n\nArguments\n\ndepth::Int: number of layers of random 2-qudit gates (brick-wall pattern) to apply to a state vector initialized with iid complex Gaussian entries.\n\nKeyword Arguments\n\nrng::AbstractRNG: random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"}]
}
