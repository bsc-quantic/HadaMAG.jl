var documenterSearchIndex = {"docs":
[{"location":"manual/ExactSRE/#Exact-Stabilizer-Rényi-Entropy-(SRE)","page":"Exact SRE","title":"Exact Stabilizer Rényi Entropy (SRE)","text":"The Stabilizer Rényi Entropy (SRE) of order q is a measure of the non-stabilizer content of a pure quantum state  ψ . Under the hood, HadaMAG.SRE(ψ, q) dispatches to one of several backends (:serial, :threads, or :mpi) and uses a sequence of Fast Hadamard Transforms to reduce the naive O(4^n) sum down to O(n2^n) work.\n\nBy default, backend = :auto chooses the fastest available execution engine. For details on available backends and MPI usage, see the Backend Configuration guide.","category":"section"},{"location":"manual/ExactSRE/#Usage","page":"Exact SRE","title":"Usage","text":"julia> using HadaMAG\n\n# Prepare a Haar random state of size L with a specified depth\njulia> L = 8; ψ = rand_haar(L; depth=2)\n\n# Compute the 2nd-order SRE with automatic backend selection (in this case, muli-threaded)\njulia> SRE(ψ, 2)\n[==================================================] 100.0%  (256/256)\n(6.009572767520443, 4.440892098500626e-16)\n\n# Force the serial backend (not multi-threaded)\njulia> SRE(ψ, 2; backend = :serial)\n[==================================================] 100.0%  (256/256)\n(6.0095727675204405, 6.661338147750939e-16)\n\nIn each call you get a tuple (entropy, lost_norm), where lost_norm is the numerical deviation from unit norm after applying the algorithm.","category":"section"},{"location":"manual/ExactSRE/#API-Reference","page":"Exact SRE","title":"API Reference","text":"","category":"section"},{"location":"manual/ExactSRE/#HadaMAG.SRE","page":"Exact SRE","title":"HadaMAG.SRE","text":"SRE(ψ::StateVec{T,2}; backend = :auto)\n\nCompute the exact Stabilizer Renyi entropy (q) of a quantum state ψ using the HadaMAG algorithm. Returns the SRE value and the lost norm of the state vector.\n\nArguments\n\nψ: A StateVec object representing the quantum state.\nq: The Renyi index (the most common value is 2).\n\nKeyword Arguments\n\nbackend: The backend to use for the computation. Default is :auto, which selects the best available backend.\nprogress: Whether to show a progress bar. Default to true.\n\n\n\n\n\n","category":"function"},{"location":"manual/MCSRE/#Monte-Carlo-Stabilizer-Rényi-Entropy-(MC-SRE)","page":"Monte Carlo SRE","title":"Monte Carlo Stabilizer Rényi Entropy (MC-SRE)","text":"The HadaMAG.jl library provides a Monte Carlo method for estimating the Stabilizer Rényi Entropy of order q for a pure quantum state ψ.\n\nThe HadaMAG.MC_SRE(ψ, q; Nsamples=1000, Nβ=13, backend=:auto) function estimates the SRE using a Monte Carlo sampling approach, where Nsamples is the number of samples to draw and Nβ is the number of discrete distribution points used in the estimation.\n\nUnder the hood, HadaMAG.MC_SRE(ψ, q) dispatches to one of several backends (:serial, :threads, or :mpi). By default, backend = :auto chooses the fastest available execution engine. For details on available backends and MPI usage, see the Backend Configuration guide.","category":"section"},{"location":"manual/MCSRE/#Usage","page":"Monte Carlo SRE","title":"Usage","text":"julia> using HadaMAG\n\n# Prepare a Haar random state of size L with a specified depth\njulia> L = 8; ψ = rand_haar(L; depth=2)\n\n# Compute the exact 2nd-order SRE for reference\njulia> SRE(ψ, 2)\n[==================================================] 100.0%  (256/256)\n(6.005977237090554, 6.661338147750939e-16)\n\n# Estimate the 2nd-order SRE using Monte Carlo with 1000 samples\njulia> MC_SRE(ψ, 2; Nsamples=1000)\n[==================================================] 100.0%  (1000/1000)\n5.9989388155066194\n\n# Estimate the 2nd-order SRE using Monte Carlo with 10000 samples\njulia> MC_SRE(ψ, 2; Nsamples=10000)\n[==================================================] 100.0%  (10000/10000)\n6.00198832046363","category":"section"},{"location":"manual/Mana/#Mana-Computation","page":"Mana Computation","title":"Mana Computation","text":"The HadaMAG.jl library also provides functionality to compute the mana of a quantum state for qutrits. Similar to HadaMAG.SRE, the HadaMAG.Mana(ψ) function computes the exact mana using Fast Hadamard Transforms (FHT) to reduce the naive ? complexity down to ?.\n\nUnder the hood, HadaMAG.Mana(ψ, q) dispatches to one of several backends (:serial, :threads, or :mpi).\n\nBy default, backend = :auto chooses the fastest available execution engine. For details on available backends and MPI usage, see the Backend Configuration guide.","category":"section"},{"location":"manual/Mana/#Usage","page":"Mana Computation","title":"Usage","text":"julia> using HadaMAG\n\n# Prepare a random state of size L=6\njulia> L = 6; amplitudes = rand(ComplexF64, 3^L);\n\njulia> ψ = StateVec(amplitudes; q=3); normalize!(ψ); ψ\nStateVec{ComplexF64,3}(n=6, dim=729, mem=11.4 KiB)\n\n# Compute the mana with automatic backend selection (in this case, muli-threaded)\njulia> Mana(ψ)\n[==================================================] 100.0%  (729/729)\n8.556666992528807\n\n# Force the serial backend (not multi-threaded)\njulia> Mana(ψ; backend = :serial)\n[==================================================] 100.0%  (729/729)\n8.556666992528806","category":"section"},{"location":"manual/State/#State-representation-in-HadaMAG.jl","page":"State Representation","title":"State representation in HadaMAG.jl","text":"In HadaMAG.jl, the StateVec{T,q} type provides a simple, efficient representation of an n-qudit (local dimension q) quantum state in the computational basis, with support for constructing from raw amplitude vectors, generating Haar-random states, loading from common on-disk formats and other utilities.","category":"section"},{"location":"manual/State/#Constructing-a-StateVec{T,q}","page":"State Representation","title":"Constructing a StateVec{T,q}","text":"Create from an existing amplitude vector (must have length = q^n):\n\njulia> using HadaMAG\n\njulia> amplitudes = randn(ComplexF64, 2^4);\n\njulia> ψ = StateVec(amplitudes) # defaults to q=2 (qubits)\nStateVec{ComplexF64,2}(n=4, dim=16, mem=296.0 B)\n\nOr specify a non-qubit local dimension:\n\njulia> amplitudes = randn(ComplexF64, 3^3);\n\njulia> ψ = StateVec(amplitudes; q=3) # qutrits\nStateVec{ComplexF64,3}(n=3, dim=27, mem=472.0 B)","category":"section"},{"location":"manual/State/#Density-Matrices","page":"State Representation","title":"Density Matrices","text":"HadaMAG.jl also provides with the DensityMatrix{T,q} struct to represent mixed states. Additionally, you can compute the reduced density matrix of a pure state ψ::StateVec{T,q} using the reduced_density_matrix function:\n\njulia> ψ = StateVec(amplitudes)\nStateVec{ComplexF64,2}(n=4, dim=16, mem=296.0 B)\n\njulia> ρA = reduced_density_matrix(ψ, 2; side=:right)\nDensityMatrix{ComplexF64,2}(n=2, dim=4, mem=304.0 B)","category":"section"},{"location":"manual/State/#Sampling-Haar-random-states","page":"State Representation","title":"Sampling Haar-random states","text":"Generate a Haar-random state on n qubits, using depth layers of random 2-qubit gates:\n\njulia> ψ = rand_haar(4; depth=3)\nStateVec{Float64,2}(n=4, dim=16, mem=...)","category":"section"},{"location":"manual/State/#Loading-a-state-vector-from-disk","page":"State Representation","title":"Loading a state vector from disk","text":"You can load amplitude data from various on-disk formats into a StateVec. The data is not renormalized automatically, so make sure your file encodes a unit-norm state.\n\nSupported formats (by extension):\n\n.jld2: JLD2 format (with JLD2.jl)\n.npy: NumPy format (with NPZ.jl)\n.txt and other text formats: Whitespace-delimited real and imaginary parts.\n\njulia> using LinearAlgebra\n\njulia> ψ = load_state(\"state_L_12.txt\")\nStateVec{ComplexF64,2}(n=12, dim=4096, mem=64.0 KiB)\n\njulia> norm(ψ)\n1.0","category":"section"},{"location":"manual/State/#API-Reference","page":"State Representation","title":"API Reference","text":"","category":"section"},{"location":"manual/State/#HadaMAG.rand_haar","page":"State Representation","title":"HadaMAG.rand_haar","text":"rand_haar(n::Int, depth::Int; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-random state on n qubits of local dimension 2, normalized to unit norm.\n\nArguments\n\ndepth::Int: number of layers of random 2-qudit gates (brick-wall pattern) to apply to a state vector initialized with iid complex Gaussian entries.\nq::Int: dimension of each qudit (default = 2).\n\nKeyword Arguments\n\nrng::AbstractRNG: random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"manual/State/#HadaMAG.load_state","page":"State Representation","title":"HadaMAG.load_state","text":"load_state(path::AbstractString; q::Int = 2) -> StateVec\n\nLoad a state vector from disk into a StateVec. The loaded vector is not renormalized; ensure it has unit norm if required.\n\nSupported formats (by file extension):\n\n.jld2: Reads dataset \"state\" via JLD2.jl.\n.npy:  Reads NumPy array via NPZ.jl.\nOtherwise: Whitespace-delimited real and imaginary parts.\n\nArguments\n\npath: Path to the file containing state amplitudes.\nq: Dimension of each qudit (default = 2).\n\nReturns\n\nA StateVec constructed from the loaded data.\n\n\n\n\n\n","category":"function"},{"location":"manual/Backends/#Backend-Configuration","page":"Backend Configuration","title":"Backend Configuration","text":"HadaMAG can run its kernels on different execution engines depending on your hardware and environment. We call these backends.\n\nThere are three available backends:\n\nSerial – single-threaded CPU execution.\nThreaded – multi-threaded CPU execution (uses Julia Threads).\nMPIThreads – hybrid MPI + threads execution (one or more threads per MPI rank).\n\nYou choose the backend with the backend keyword in user-facing functions, e.g.:\n\njulia> SRE(ψ, q; backend = :auto)   # default is :auto","category":"section"},{"location":"manual/Backends/#Backend-types-and-symbols","page":"Backend Configuration","title":"Backend types and symbols","text":"Internally we define three backend types:\n\nabstract type AbstractBackend end\nstruct Serial      <: AbstractBackend end\nstruct Threaded    <: AbstractBackend end\nstruct MPIThreads  <: AbstractBackend end  # defined even if MPI is absent\n\nThese map to the following keyword symbols:\n\nbackend = :serial to Serial().\nbackend = :threads to Threaded().\nbackend = :mpi to MPIThreads().\nbackend = :auto (default) to automatic selection.\n\nYou can force an specific backend by passing the corresponding symbol to user functions:\n\njulia> using HadaMAG\n\njulia> ψ = rand_haar(8; depth=2)\n\njulia> SRE(ψ, 2; backend = :threads)\n(6.0095727675204405, 6.661338147750939e-16)","category":"section"},{"location":"manual/Backends/#MPI-support-via-HadaMAGMPIExt-extension","page":"Backend Configuration","title":"MPI support via HadaMAGMPIExt extension","text":"Julia’s package extensions let us ship MPI code without hard-requiring MPI for everyone. Instead, The extension HadaMAGMPIExt is automatically discovered by Julia and activated when MPI.jl is loaded in your session.\n\nAs a user, you need to load MPI.jl before using HadaMAG with MPI:\n\njulia> using HadaMAG\n\njulia> using Pkg; Pkg.add(\"MPI\"); using MPI\nPrecompiling HadaMAGMPIExt...\n  1 dependency successfully precompiled in 2 seconds. 341 already precompiled.\n\nThe MPI.jl package uses MPIPreferences.jl to decide which MPI implementation to load (a system MPI or a JLL/bundled MPI).\n\nUse system MPI (e.g., OpenMPI or MPICH on a cluster):\n\njulia> using MPIPreferences\n\njulia> MPIPreferences.MPIPreferences.use_system_binary()\n\nOr use a bundled MPI (e.g., OpenMPI_jll):\n\njulia> using MPIPreferences\n\njulia> MPIPreferences.MPIPreferences.use_jll_binary()\n\nYou can check which MPI you’re using with:\n\njulia> using MPI\n\njulia> MPI.identify_implementation()\n(\"MPICH\", v\"4.3.1\")\n\nThis will use the system MPI installation.","category":"section"},{"location":"manual/Backends/#Running-using-MPI","page":"Backend Configuration","title":"Running using MPI","text":"Here we show a minimal example of running HadaMAG with MPI on a cluster or laptop. Create a file run_mpi.jl with the following content:\n\nusing MPI\n\nusing HadaMAG\nL = 8\nψ = HadaMAG.rand_haar(L; depth=2)\n\nS, lost = HadaMAG.SRE(ψ, 2; backend = :mpi_threads)\n\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\nprintln(\"rank=$rank  SRE=$S  lost_norm=$lost\")\n\nThen run it with mpiexec or mpirun:\n\nmpirun -n 4 julia --project yourproject run_sre.jl\n\nOr if you are on a cluster with SLURM, you can submit a job script like this:\n\nsrun --ntasks=4 --cpus-per-task=1 julia --project yourproject run_sre.jl","category":"section"},{"location":"manual/Backends/#API-Reference","page":"Backend Configuration","title":"API Reference","text":"","category":"section"},{"location":"manual/CustomFHT/#Custom-FHT-Library","page":"Custom FHT Library","title":"Custom FHT Library","text":"Under the hood, HadaMAG’s Fast Hadamard Transform (FHT) is powered by the FastHadamardStructuredTransforms_jll package (a Julia Binary Library artifact built via the Yggdrasil infrastructure).  This gives you a portable, pre-built C library (the upstream FFHT project) out of the box, with zero fuss on installation.\n\nHowever, it is important to note that these binaries prioritize compatibility over peak performance. Therefore, by compiling FFHT yourself with optimizations tuned to your CPU (for example passing -march=native, enabling link-time optimization, or targeting advanced SIMD extensions), you can often unlock around 10-30 % faster transforms on large vectors. Since HadaMAG’s core routines rely heavily on FHT, those gains translate directly into substantial runtime savings.","category":"section"},{"location":"manual/CustomFHT/#Usage-and-Performance-Comparison","page":"Custom FHT Library","title":"Usage and Performance Comparison","text":"Here we show how we can easily switch libraries, and compare the performance of the default JLL-provided library with a custom-compiled one.\n\njulia> using HadaMAG, BenchmarkTools\n\njulia> L = 22; v = randn(2^L); # around 4 million elements\n\n# Default JLL library\njulia> @btime HadaMAG.call_fht!(v, Int32(L))\n  8.250 ms (0 allocations: 0 bytes)\n\n# Override with your custom build\njulia> HadaMAG.use_fht_lib(\"/home/user/libffht_julia.so\")\n[ Info: Using custom FHT library at /home/user/libffht_julia.so\n\njulia> @btime HadaMAG.call_fht!(v, Int32(L)) # Speedup compared to JLL\n  6.258 ms (0 allocations: 0 bytes)\n\n# We can also revert back to the default JLL library\njulia> HadaMAG.use_default_fht()\n[ Info: Reverting to default FHT library\n\njulia> @btime HadaMAG.call_fht!(v, Int32(L))\n  8.642 ms (0 allocations: 0 bytes)\n\nIn this example, we see that the custom-compiled library provides a significant speedup over the default JLL library. You can expect similar results on your own machine, depending on your CPU architecture and the optimizations you apply during compilation.","category":"section"},{"location":"manual/CustomFHT/#API-Reference","page":"Custom FHT Library","title":"API Reference","text":"","category":"section"},{"location":"manual/CustomFHT/#HadaMAG.call_fht!","page":"Custom FHT Library","title":"HadaMAG.call_fht!","text":"call_fht!(vec::Vector{Float64}, L::Int32)\n\nIn‐place fast Hadamard transform.  After an optional call to use_fht_lib, this will call through your .so instead of the default JLL library.\n\n\n\n\n\n","category":"function"},{"location":"manual/CustomFHT/#HadaMAG.use_fht_lib","page":"Custom FHT Library","title":"HadaMAG.use_fht_lib","text":"use_fht_lib(path::String)\n\nPoint at your own compiled .so that exports exactly the symbol :fht_double. After calling this, every call_fht! will invoke your library instead of the JLL one.\n\n\n\n\n\n","category":"function"},{"location":"manual/CustomFHT/#HadaMAG.use_default_fht","page":"Custom FHT Library","title":"HadaMAG.use_default_fht","text":"use_default_fht()\n\nRevert call_fht! back to the built-in FastHadamardStructuredTransforms_jll implementation.\n\n\n\n\n\n","category":"function"},{"location":"#HadaMAG.jl-Documentation","page":"Home","title":"HadaMAG.jl Documentation","text":"HadaMAG.jl is an optimized Julia library for computing the Stabilizer Rényi Entropy (SRE) on pure quantum states. Most notably, it contains:\n\nExact SRE: Computes the exact SRE using the HadaMAG algorithm, which leverages Fast Hadamard Transforms (FHT) to reduce the naive O(4^n) complexity down to O(n2^n) (see Exact SRE).\nMonte Carlo SRE: Provides a Monte Carlo method for estimating SRE (see Monte Carlo SRE).\nMana Computation: Computes the exact mana of a quantum state for qutrits (see Mana Computation).\n\nwarning: Performance tip\nIf you are dealing with significant number of qubits (N  16), you can get around 30 % speed-up by compiling and linking your own optimized FFHT library. See the Custom FHT Library guide for how to build, enable and revert your own .so.","category":"section"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"julia> using Pkg; Pkg.add(\"HadaMAG\")\n\njulia> using HadaMAG\n\n# Prepare a Haar-random 8-qubit state\njulia> ψ = rand_haar(8; depth=2)\nStateVec{ComplexF64,2}(n=8, dim=256, mem=4.04 KiB)\n\n# Compute the 2nd‐order Stabilizer Rényi Entropy\njulia> (sre2, lost_norm) = SRE(ψ, 2)\n[==================================================] 100.0%  (256/256)\n(6.028326027457565, 1.1102230246251565e-16)\n\n# Estimate the 2nd‐order SRE using Monte Carlo with 10000 samples\njulia> sre2_mc = MC_SRE(ψ, 2; Nsamples=10000)\n[==================================================] 100.0%  (10000/10000)\n6.023172434713934","category":"section"},{"location":"#Manuals","page":"Home","title":"Manuals","text":"For detailed guides on how to use HadaMAG.jl, see the following sections:\n\nState Representation: How quantum states are represented in HadaMAG.jl.\nExact SRE: How to compute the exact Stabilizer Rényi Entropy.\nBackend Configuration: How to configure and use different backends for all SRE computation.","category":"section"},{"location":"api/Helpers/#Helper-functions-in-HadaMAG.jl","page":"Helpers","title":"Helper functions in HadaMAG.jl","text":"","category":"section"},{"location":"api/Helpers/#HadaMAG.build_tmp!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{ComplexF64}}","page":"Helpers","title":"HadaMAG.build_tmp!","text":"build_tmp!(tmp1, tmp2, X)\n\nCompute tmp1 = real(X)+imag(X), tmp2 = imag(X)-real(X) in place. X is the complex state vector (length = 2^L).\n\n\n\n\n\n","category":"method"},{"location":"api/Helpers/#HadaMAG.call_fht!-Tuple{Vector{Float64}, Int32}","page":"Helpers","title":"HadaMAG.call_fht!","text":"call_fht!(vec::Vector{Float64}, L::Int32)\n\nIn‐place fast Hadamard transform.  After an optional call to use_fht_lib, this will call through your .so instead of the default JLL library.\n\n\n\n\n\n","category":"method"},{"location":"api/Helpers/#HadaMAG.haar_random_unitary","page":"Helpers","title":"HadaMAG.haar_random_unitary","text":"haar_random_unitary(n_qubits::Integer, rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-distributed random unitary matrix of size q^nqudits × q^nqudits.\n\nArguments\n\nq::Int: local dimension (2 for qubits, 3 for qutrits).\nn_qudits::Integer: number of qubits; the output U lives in U(2^n_qubits).\nrng::AbstractRNG: random number generator (defaults to GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"api/Helpers/#HadaMAG.integrate_simpson_uniform-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Helpers","title":"HadaMAG.integrate_simpson_uniform","text":"integrate_simpson_uniform(x, y) -> Float64\n\nSimpson's rule on a uniform grid x. Requires an odd number of points.\n\n\n\n\n\n","category":"method"},{"location":"api/Helpers/#HadaMAG.use_default_fht-Tuple{}","page":"Helpers","title":"HadaMAG.use_default_fht","text":"use_default_fht()\n\nRevert call_fht! back to the built-in FastHadamardStructuredTransforms_jll implementation.\n\n\n\n\n\n","category":"method"},{"location":"api/Helpers/#HadaMAG.use_fht_lib-Tuple{String}","page":"Helpers","title":"HadaMAG.use_fht_lib","text":"use_fht_lib(path::String)\n\nPoint at your own compiled .so that exports exactly the symbol :fht_double. After calling this, every call_fht! will invoke your library instead of the JLL one.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#State-API-Documentation","page":"State","title":"State API Documentation","text":"","category":"section"},{"location":"api/State/#HadaMAG.StateVec","page":"State","title":"HadaMAG.StateVec","text":"HadaMAG.jl: StateVec\n\nA lightweight container for a pure quantum state of n q-dits (q = qudit dimension, 2 for qubits) stored in the computational basis |0⋯00⟩, |0⋯01⟩, …, |q−1⋯(q−1)⟩.\n\n\n\n\n\n","category":"type"},{"location":"api/State/#HadaMAG.StateVec-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"State","title":"HadaMAG.StateVec","text":"StateVec(vec::AbstractVector{<:Complex}; q::Int = 2)\n\nCreate a StateVec from an existing amplitude vector vec. Throws ArgumentError if length(vec) is not an exact power of q.\n\nArguments\n\nvec: Vector of complex amplitudes.\nq: Dimension of each qudit (default = 2 for qubits).\n\nReturns\n\nA StateVec containing a copy of vec and inferred n & q.\n\nExample\n\njulia> ψ = randn(ComplexF64, 2^4);\njulia> StateVec(ψ) # defaults to qubits\nStateVec{Float64,2}(n=4, q=2)\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_2gate!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 1}, AbstractArray{Complex{T}, 2}, Int64, Int64}} where T","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(state::AbstractVector{Complex{T}}, gate::AbstractMatrix{Complex{T}}, q1::Int, q2::Int)\n\nApply in-place a two-qubit gate (4×4 matrix) to qubits q1,q2 (1-based) on state. state must have length 2^n and contain amplitude data in computational basis.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_2gate!-Union{Tuple{q}, Tuple{T}, Tuple{StateVec{T, q}, AbstractMatrix{T}, Int64, Int64}} where {T<:Complex, q}","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(sv::StateVec{T,2}, gate::AbstractMatrix{T}, q1::Int, q2::Int)\n\nApply a two-qubit gate directly on a StateVec{T,2}.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_brick_wall_haar!-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer, Integer}, Tuple{AbstractVector{T}, Integer, Integer, Random.AbstractRNG}} where T<:Complex","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(state::AbstractVector{ComplexF64}, nqubits::Integer, depth::Integer; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply an in-place “brick-wall” of Haar-random 2-qubit unitaries to state. The circuit has depth layers; odd layers act on qubits (1,2),(3,4)…, even on (2,3),(4,5)…\n\nArguments\n\nstate: length-2^nqubits state vector (will be mutated).\nnqubits: number of qubits.\ndepth: number of alternating layers.\nrng: keyword RNG (defaults to GLOBAL_RNG).\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_brick_wall_haar!-Union{Tuple{q}, Tuple{T}, Tuple{StateVec{T, q}, Int64}, Tuple{StateVec{T, q}, Int64, Random.AbstractRNG}} where {T, q}","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(ψ::StateVec{T,q}, L::Int, depth::Int, rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply a brick-wall Haar-random circuit to a state vector vec in-place. The circuit consists of depth layers of random unitary 2-qudit gates, alternating between even and odd qudit pairs.\n\nArguments\n\nψ: StateVec to be modified.\ndepth: Number of layers of gates.\nrng: Random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.load_state-Tuple{AbstractString}","page":"State","title":"HadaMAG.load_state","text":"load_state(path::AbstractString; q::Int = 2) -> StateVec\n\nLoad a state vector from disk into a StateVec. The loaded vector is not renormalized; ensure it has unit norm if required.\n\nSupported formats (by file extension):\n\n.jld2: Reads dataset \"state\" via JLD2.jl.\n.npy:  Reads NumPy array via NPZ.jl.\nOtherwise: Whitespace-delimited real and imaginary parts.\n\nArguments\n\npath: Path to the file containing state amplitudes.\nq: Dimension of each qudit (default = 2).\n\nReturns\n\nA StateVec constructed from the loaded data.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.rand_haar-Tuple{Int64}","page":"State","title":"HadaMAG.rand_haar","text":"rand_haar(n::Int, depth::Int; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-random state on n qubits of local dimension 2, normalized to unit norm.\n\nArguments\n\ndepth::Int: number of layers of random 2-qudit gates (brick-wall pattern) to apply to a state vector initialized with iid complex Gaussian entries.\nq::Int: dimension of each qudit (default = 2).\n\nKeyword Arguments\n\nrng::AbstractRNG: random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.DensityMatrix","page":"State","title":"HadaMAG.DensityMatrix","text":"HadaMAG.jl: DensityMatrix\n\nA lightweight container for a mixed quantum state of n q-dits (q = qudit dimension, 2 for qubits) stored in the computational basis |0⋯00⟩, |0⋯01⟩, …, |q−1⋯(q−1)⟩.\n\n\n\n\n\n","category":"type"},{"location":"api/State/#HadaMAG.DensityMatrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"State","title":"HadaMAG.DensityMatrix","text":"DensityMatrix(mat::AbstractMatrix{<:Complex}; q::Int = 2)\n\nCreate a DensityMatrix from an existing density matrix mat. Throws ArgumentError if mat is not square or if its size is not an exact power of q.\n\nArguments\n\nmat: Square matrix of complex amplitudes.\nq: Dimension of each qudit (default = 2 for qubits).\n\nReturns\n\nA DensityMatrix containing a copy of mat and inferred n & q.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_M_tensor_N_inplace!-Union{Tuple{Tc}, Tuple{AbstractVector{Tc}, AbstractMatrix{Tc}, Int64}} where Tc<:Complex","page":"State","title":"HadaMAG.apply_M_tensor_N_inplace!","text":"apply_M_tensor_N_inplace!(v, M, N)\n\nIn-place apply M^{⊗N} to v (length 9^N), sweeping legs like the C++ code. M must be 9×9.\n\nLeg 1 corresponds to the most significant base-9 digit (same as C++).\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.build_single_qutrit_M-Tuple{}","page":"State","title":"HadaMAG.build_single_qutrit_M","text":"build_single_qutrit_M()\n\nReturn (M, A_list) where:\n\nA_list[idx] is the 3×3 phase-point operator A_u (u ≡ idx in 0..8),\nM is 9×9 such that for one qutrit: w = M * vec(rho) (column-major vec)   and w[idx] = tr(A_list[idx] * rho).\n\nThis matches the C++ construction exactly (including the use of vec(A_u^T) as rows of M).\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.mana-Union{Tuple{T}, Tuple{StateVec{T, 3}, Int64}} where T<:Complex","page":"State","title":"HadaMAG.mana","text":"mana(ψ::StateVec{<:Complex,3}, NA; side=:right)\n\nCompute mana of the NA-qutrit reduced state of the pure qutrit state ψ.\n\nReturns (mana, trρA, tra) where:\n\ntrρA ≈ 1 (real)\ntra = sum(w)/dA should be ≈ 1 + 0im if conventions match.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.phase_space_expectations_fast-Union{Tuple{DensityMatrix{T, 3}}, Tuple{T}} where T<:Complex","page":"State","title":"HadaMAG.phase_space_expectations_fast","text":"phase_space_expectations_fast(ρ::DensityMatrix{<:Complex,3})\n\nReturn the length-9^N vector of phase-space expectation values for an N-qutrit density matrix ρ.\n\nThis matches the C++ pipeline: v = vecrhotensor_N(ρ) v ← (M^{⊗N}) v\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.reduced_density_matrix-Union{Tuple{q}, Tuple{T}, Tuple{StateVec{T, q}, Int64}} where {T<:Complex, q}","page":"State","title":"HadaMAG.reduced_density_matrix","text":"reduced_density_matrix(ψ, NA; q=3, side=:right)\n\nCompute the reduced density matrix ρA = Tr_B(|ψ⟩⟨ψ|) for a contiguous bipartition of an N-site qudit state (with local dimension q), where dimA = q^NA and dimB = q^(N-NA).\n\nThe keyword argument side selects which end of the chain is kept as subsystem A (assuming the usual convention in this codebase that site 1 is the least-significant digit in the linear index, consistent with using q^(s-1) for site s):\n\nside = :left  keeps sites 1:NA (least-significant / fastest-varying block): ρA[iA,jA] = ∑_{kB=0}^{dimB-1} ψ[iA + dimA*kB] * conj(ψ[jA + dimA*kB]).\nside = :right keeps sites (N-NA+1):N (most-significant / slowest-varying block), matching the C++ convention i = iA*dimB + kB: ρA[iA,jA] = ∑_{kB=0}^{dimB-1} ψ[iA*dimB + kB] * conj(ψ[jA*dimB + kB]).\n\nReturns a DensityMatrix(ρA; q=q) of size q^NA × q^NA.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.vec_rho_tensor_N-Union{Tuple{Tc}, Tuple{AbstractMatrix{Tc}, Int64}} where Tc<:Complex","page":"State","title":"HadaMAG.vec_rho_tensor_N","text":"vec_rho_tensor_N(rho::AbstractMatrix, N::Int)\n\nMap a 3^N×3^N density matrix rho (column-major) to a vector v of length 9^N such that each site contributes an index idx9 = 3*ik + jk.\n\nThis matches the C++ digit convention: the vector legs are ordered MSB→LSB in base-3.\n\n\n\n\n\n","category":"method"}]
}
