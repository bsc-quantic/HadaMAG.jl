var documenterSearchIndex = {"docs":
[{"location":"manual/ExactSRE/#Exact-Stabilizer-Rényi-Entropy-(SRE)","page":"Exact SRE","title":"Exact Stabilizer Rényi Entropy (SRE)","text":"","category":"section"},{"location":"manual/ExactSRE/","page":"Exact SRE","title":"Exact SRE","text":"The Stabilizer Rényi Entropy (SRE) of order q is a measure of the non-stabilizer content of a pure quantum state  ψ . Under the hood, HadaMAG.SRE(ψ, q) dispatches to one of several backends (:serial, :threads, or :mpi) and uses a sequence of Fast Hadamard Transforms to reduce the naive O(4^n) sum down to O(n2^n) work.","category":"page"},{"location":"manual/ExactSRE/","page":"Exact SRE","title":"Exact SRE","text":"By default, backend = :auto chooses the fastest available execution engine. For details on available backends and MPI usage, see the Backend Configuration guide.","category":"page"},{"location":"manual/ExactSRE/#Usage","page":"Exact SRE","title":"Usage","text":"","category":"section"},{"location":"manual/ExactSRE/","page":"Exact SRE","title":"Exact SRE","text":"julia> using HadaMAG\n\n# Prepare a Haar random state of size L with a specified depth\njulia> L = 8; ψ = rand_haar(L; depth=2)\n\n# Compute the 2nd-order SRE with automatic backend selection (in this case, muli-threaded)\njulia> SRE(ψ, 2)\n(6.009572767520443, 4.440892098500626e-16)\n\n# Force the serial backend (not multi-threaded)\njulia> SRE(ψ, 2; backend = :serial)\n(6.0095727675204405, 6.661338147750939e-16)","category":"page"},{"location":"manual/ExactSRE/","page":"Exact SRE","title":"Exact SRE","text":"In each call you get a tuple (entropy, lostnorm), where lostnorm is the numerical deviation from unit norm after the sequence of FHTs.","category":"page"},{"location":"manual/ExactSRE/#API-Reference","page":"Exact SRE","title":"API Reference","text":"","category":"section"},{"location":"manual/ExactSRE/#HadaMAG.SRE","page":"Exact SRE","title":"HadaMAG.SRE","text":"SRE(ψ::StateVec{T,2}; backend = :auto)\n\nCompute the exact Stabilizer Renyi entropy (q) of a quantum state ψ using the HadaMAG algorithm. Returns the SRE value and the lost norm of the state vector.\n\nArguments\n\nψ: A StateVec object representing the quantum state.\nbackend: The backend to use for the computation. Default is :auto, which selects the best available backend.\n\n\n\n\n\n","category":"function"},{"location":"manual/State/#State-representation-in-HadaMAG.jl","page":"State Representation","title":"State representation in HadaMAG.jl","text":"","category":"section"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"In HadaMAG.jl, the StateVec{T,q} type provides a simple, efficient representation of an n-qudit (local dimension q) quantum state in the computational basis, with support for constructing from raw amplitude vectors, generating Haar-random states, loading from common on-disk formats and other utilities.","category":"page"},{"location":"manual/State/#Constructing-a-StateVec{T,q}","page":"State Representation","title":"Constructing a StateVec{T,q}","text":"","category":"section"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"Create from an existing amplitude vector (must have length = q^n):","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"julia> using HadaMAG\n\njulia> amplitudes = randn(ComplexF64, 2^4);\n\njulia> ψ = StateVec(amplitudes) # defaults to q=2 (qubits)\nStateVec{ComplexF64,2}(n=4, dim=16, mem=296.0 B)","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"Or specify a non-qubit local dimension:","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"julia> amplitudes = randn(ComplexF64, 3^3);\n\njulia> ψ = StateVec(amplitudes; q=3) # qutrits\nStateVec{ComplexF64,3}(n=3, dim=27, mem=472.0 B)","category":"page"},{"location":"manual/State/#Sampling-Haar-random-states","page":"State Representation","title":"Sampling Haar-random states","text":"","category":"section"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"Generate a Haar-random state on n qubits, using depth layers of random 2-qubit gates:","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"julia> ψ = rand_haar(4; depth=3)\nStateVec{Float64,2}(n=4, dim=16, mem=...)","category":"page"},{"location":"manual/State/#Loading-a-state-vector-from-disk","page":"State Representation","title":"Loading a state vector from disk","text":"","category":"section"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"You can load amplitude data from various on-disk formats into a StateVec. The data is not renormalized automatically, so make sure your file encodes a unit-norm state.","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"Supported formats (by extension):","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":".jld2: JLD2 format (with JLD2.jl)\n.npy: NumPy format (with NPZ.jl)\n.txt and other text formats: Whitespace-delimited real and imaginary parts.","category":"page"},{"location":"manual/State/","page":"State Representation","title":"State Representation","text":"julia> using LinearAlgebra\n\njulia> ψ = load_state(\"state_L_12.txt\")\nStateVec{ComplexF64,2}(n=12, dim=4096, mem=64.0 KiB)\n\njulia> norm(ψ)\n1.0","category":"page"},{"location":"manual/State/#API-Reference","page":"State Representation","title":"API Reference","text":"","category":"section"},{"location":"manual/State/#HadaMAG.rand_haar","page":"State Representation","title":"HadaMAG.rand_haar","text":"rand_haar(n::Int, depth::Int; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-random state on n qubits of local dimension 2, normalized to unit norm.\n\nArguments\n\ndepth::Int: number of layers of random 2-qudit gates (brick-wall pattern) to apply to a state vector initialized with iid complex Gaussian entries.\n\nKeyword Arguments\n\nrng::AbstractRNG: random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"manual/State/#HadaMAG.load_state","page":"State Representation","title":"HadaMAG.load_state","text":"load_state(path::AbstractString; q::Int = 2) -> StateVec\n\nLoad a state vector from disk into a StateVec. The loaded vector is not renormalized; ensure it has unit norm if required.\n\nSupported formats (by file extension):\n\n.jld2: Reads dataset \"state\" via JLD2.jl.\n.npy:  Reads NumPy array via NPZ.jl.\nOtherwise: Whitespace-delimited real and imaginary parts.\n\nArguments\n\npath: Path to the file containing state amplitudes.\nq: Dimension of each qudit (default = 2).\n\nReturns\n\nA StateVec constructed from the loaded data.\n\n\n\n\n\n","category":"function"},{"location":"manual/CustomFHT/#Custom-FHT-Library","page":"Custom FHT Library","title":"Custom FHT Library","text":"","category":"section"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"Under the hood, HadaMAG’s Fast Hadamard Transform (FHT) is powered by the FastHadamardStructuredTransforms_jll package (a Julia Binary Library artifact built via the Yggdrasil infrastructure).  This gives you a portable, pre-built C library (the upstream FFHT project) out of the box, with zero fuss on installation.","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"However, it is important to note that these binaries prioritize compatibility over peak performance. Therefore, by compiling FFHT yourself with optimizations tuned to your CPU (for example passing -march=native, enabling link-time optimization, or targeting advanced SIMD extensions), you can often unlock around 10-30 % faster transforms on large vectors. Since HadaMAG’s core routines rely heavily on FHT, those gains translate directly into substantial runtime savings.","category":"page"},{"location":"manual/CustomFHT/#Usage-and-Performance-Comparison","page":"Custom FHT Library","title":"Usage and Performance Comparison","text":"","category":"section"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"Here we show how we can easily switch libraries, and compare the performance of the default JLL-provided library with a custom-compiled one.","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"julia> using HadaMAG, BenchmarkTools\n\njulia> L = 22; v = randn(2^L); # around 4 million elements\n\n# Default JLL library\njulia> @btime HadaMAG.call_fht!(v, Int32(L))\n  8.250 ms (0 allocations: 0 bytes)\n\n# Override with your custom build\njulia> HadaMAG.use_fht_lib(\"/home/user/libffht_julia.so\")\n[ Info: Using custom FHT library at /home/user/libffht_julia.so\n\njulia> @btime HadaMAG.call_fht!(v, Int32(L)) # Speedup compared to JLL\n  6.258 ms (0 allocations: 0 bytes)\n\n# We can also revert back to the default JLL library\njulia> HadaMAG.use_default_fht()\n[ Info: Reverting to default FHT library\n\njulia> @btime HadaMAG.call_fht!(v, Int32(L))\n  8.642 ms (0 allocations: 0 bytes)","category":"page"},{"location":"manual/CustomFHT/","page":"Custom FHT Library","title":"Custom FHT Library","text":"In this example, we see that the custom-compiled library provides a significant speedup over the default JLL library. You can expect similar results on your own machine, depending on your CPU architecture and the optimizations you apply during compilation.","category":"page"},{"location":"manual/CustomFHT/#API-Reference","page":"Custom FHT Library","title":"API Reference","text":"","category":"section"},{"location":"manual/CustomFHT/#HadaMAG.call_fht!","page":"Custom FHT Library","title":"HadaMAG.call_fht!","text":"call_fht!(vec::Vector{Float64}, L::Int32)\n\nIn‐place fast Hadamard transform.  After an optional call to use_fht_lib, this will call through your .so instead of the default JLL library.\n\n\n\n\n\n","category":"function"},{"location":"manual/CustomFHT/#HadaMAG.use_fht_lib","page":"Custom FHT Library","title":"HadaMAG.use_fht_lib","text":"use_fht_lib(path::String)\n\nPoint at your own compiled .so that exports exactly the symbol :fht_double. After calling this, every call_fht! will invoke your library instead of the JLL one.\n\n\n\n\n\n","category":"function"},{"location":"manual/CustomFHT/#HadaMAG.use_default_fht","page":"Custom FHT Library","title":"HadaMAG.use_default_fht","text":"use_default_fht()\n\nRevert call_fht! back to the built-in FastHadamardStructuredTransforms_jll implementation.\n\n\n\n\n\n","category":"function"},{"location":"#HadaMAG.jl-Documentation","page":"Home","title":"HadaMAG.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HadaMAG.jl is an optimized Julia library for computing the Stabilizer Rényi Entropy (SRE) on pure quantum states. Most notably, it contains:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Exact SRE: Computes the exact SRE using the HadaMAG algorithm, which leverages Fast Hadamard Transforms (FHT) to reduce the naive O(4^n) complexity down to O(n2^n).\nMonte Carlo SRE: Provides a Monte Carlo method for estimating SRE.\nMana Computation: Computes the mana of a quantum state for qutrits in a Monte Carlo fashion.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Performance tip\nIf you are dealing with significant number of qubits (N  16), you can get around 30 % speed-up by compiling and linking your own optimized FFHT library. See the Custom FHT Library guide for how to build, enable and revert your own .so.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"HadaMAG\")\n\njulia> using HadaMAG\n\n# Prepare a Haar-random 8-qubit state\njulia> ψ = rand_haar(8; depth=2)\nStateVec{ComplexF64,2}(n=8, dim=256, mem=4.04 KiB)\n\n# Compute the 2nd‐order Stabilizer Rényi Entropy\njulia> (sre2, lost_norm) = SRE(ψ, 2)\n(6.028326027457565, 1.1102230246251565e-16)\n\n# Estimate the 2nd‐order SRE using Monte Carlo with 10000 samples\njulia> sre2_mc = MC_SRE(ψ, 2; Nsamples=10000)\n6.023172434713934","category":"page"},{"location":"#Manuals","page":"Home","title":"Manuals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For detailed guides on how to use HadaMAG.jl, see the following sections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"State Representation: How quantum states are represented in HadaMAG.jl.\nExact SRE: How to compute the exact Stabilizer Rényi Entropy.\nBackend Configuration: How to configure and use different backends for all SRE computation.","category":"page"},{"location":"api/Helpers/#Helper-functions-in-HadaMAG.jl","page":"Helpers","title":"Helper functions in HadaMAG.jl","text":"","category":"section"},{"location":"api/Helpers/#HadaMAG.call_fht!-Tuple{Vector{Float64}, Int32}","page":"Helpers","title":"HadaMAG.call_fht!","text":"call_fht!(vec::Vector{Float64}, L::Int32)\n\nIn‐place fast Hadamard transform.  After an optional call to use_fht_lib, this will call through your .so instead of the default JLL library.\n\n\n\n\n\n","category":"method"},{"location":"api/Helpers/#HadaMAG.haar_random_unitary","page":"Helpers","title":"HadaMAG.haar_random_unitary","text":"haar_random_unitary(n_qubits::Integer, rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-distributed random unitary matrix of size 2^nqubits × 2^nqubits.\n\nArguments\n\nn_qubits::Integer: number of qubits; the output U lives in U(2^n_qubits).\nrng::AbstractRNG: random number generator (defaults to GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"api/Helpers/#HadaMAG.use_default_fht-Tuple{}","page":"Helpers","title":"HadaMAG.use_default_fht","text":"use_default_fht()\n\nRevert call_fht! back to the built-in FastHadamardStructuredTransforms_jll implementation.\n\n\n\n\n\n","category":"method"},{"location":"api/Helpers/#HadaMAG.use_fht_lib-Tuple{String}","page":"Helpers","title":"HadaMAG.use_fht_lib","text":"use_fht_lib(path::String)\n\nPoint at your own compiled .so that exports exactly the symbol :fht_double. After calling this, every call_fht! will invoke your library instead of the JLL one.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#State-API-Documentation","page":"State","title":"State API Documentation","text":"","category":"section"},{"location":"api/State/#HadaMAG.StateVec","page":"State","title":"HadaMAG.StateVec","text":"StateVec\n\nA lightweight container for a pure quantum state of n q-dits (q = qudit dimension, 2 for qubits) stored in the computational basis |0⋯00⟩, |0⋯01⟩, …, |q−1⋯(q−1)⟩.\n\n\n\n\n\n","category":"type"},{"location":"api/State/#HadaMAG.StateVec-Union{Tuple{AbstractVector{<:Complex{T}}}, Tuple{T}} where T","page":"State","title":"HadaMAG.StateVec","text":"StateVec(vec::AbstractVector{<:Complex}; q::Int = 2)\n\nCreate a StateVec from an existing amplitude vector vec. Throws ArgumentError if length(vec) is not an exact power of q.\n\nArguments\n\nvec: Vector of complex amplitudes.\nq: Dimension of each qudit (default = 2 for qubits).\n\nReturns\n\nA StateVec containing a copy of vec and inferred n & q.\n\nExample\n\njulia> ψ = randn(ComplexF64, 2^4);\njulia> StateVec(ψ) # defaults to qubits\nStateVec{Float64,2}(n=4, q=2)\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_2gate!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}, 1}, AbstractArray{Complex{T}, 2}, Int64, Int64}} where T","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(state::AbstractVector{Complex{T}}, gate::AbstractMatrix{Complex{T}}, q1::Int, q2::Int)\n\nApply in-place a two-qubit gate (4×4 matrix) to qubits q1,q2 (1-based) on state. state must have length 2^n and contain amplitude data in computational basis.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_2gate!-Union{Tuple{T}, Tuple{StateVec{T, 2}, AbstractArray{Complex{T}, 2}, Int64, Int64}} where T","page":"State","title":"HadaMAG.apply_2gate!","text":"apply_2gate!(sv::StateVec{T,2}, gate::AbstractMatrix{Complex{T}}, q1::Int, q2::Int)\n\nApply a two-qubit gate directly on a StateVec{T,2}.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.apply_brick_wall_haar!","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(state::AbstractVector{ComplexF64}, nqubits::Integer, depth::Integer; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply an in-place “brick-wall” of Haar-random 2-qubit unitaries to state. The circuit has depth layers; odd layers act on qubits (1,2),(3,4)…, even on (2,3),(4,5)…\n\nArguments\n\nstate: length-2^nqubits state vector (will be mutated).\nnqubits: number of qubits.\ndepth: number of alternating layers.\nrng: keyword RNG (defaults to GLOBAL_RNG).\n\n\n\n\n\n","category":"function"},{"location":"api/State/#HadaMAG.apply_brick_wall_haar!-Union{Tuple{T}, Tuple{StateVec{T, 2}, Int64}, Tuple{StateVec{T, 2}, Int64, Random.AbstractRNG}} where T","page":"State","title":"HadaMAG.apply_brick_wall_haar!","text":"apply_brick_wall_haar!(ψ::StateVec{T,2}, L::Int, depth::Int, rng::AbstractRNG = Random.GLOBAL_RNG)\n\nApply a brick-wall Haar-random circuit to a state vector vec in-place. The circuit consists of depth layers of random unitary 2-qubit gates, alternating between even and odd qubit pairs.\n\nArguments\n\nψ: StateVec to be modified.\ndepth: Number of layers of gates.\nrng: Random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.load_state-Tuple{AbstractString}","page":"State","title":"HadaMAG.load_state","text":"load_state(path::AbstractString; q::Int = 2) -> StateVec\n\nLoad a state vector from disk into a StateVec. The loaded vector is not renormalized; ensure it has unit norm if required.\n\nSupported formats (by file extension):\n\n.jld2: Reads dataset \"state\" via JLD2.jl.\n.npy:  Reads NumPy array via NPZ.jl.\nOtherwise: Whitespace-delimited real and imaginary parts.\n\nArguments\n\npath: Path to the file containing state amplitudes.\nq: Dimension of each qudit (default = 2).\n\nReturns\n\nA StateVec constructed from the loaded data.\n\n\n\n\n\n","category":"method"},{"location":"api/State/#HadaMAG.rand_haar-Tuple{Int64}","page":"State","title":"HadaMAG.rand_haar","text":"rand_haar(n::Int, depth::Int; rng::AbstractRNG = Random.GLOBAL_RNG)\n\nGenerate a Haar-random state on n qubits of local dimension 2, normalized to unit norm.\n\nArguments\n\ndepth::Int: number of layers of random 2-qudit gates (brick-wall pattern) to apply to a state vector initialized with iid complex Gaussian entries.\n\nKeyword Arguments\n\nrng::AbstractRNG: random number generator (default = Random.GLOBAL_RNG).\n\n\n\n\n\n","category":"method"}]
}
